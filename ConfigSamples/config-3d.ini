# For Prime alpha
[general]
grbl_mode = false

[motion control]
default_feed_rate = 4000 # Default speed (mm/minute) for G1/G2/G3 moves
default_seek_rate = 4000 # Default speed (mm/minute) for G0 moves
mm_per_arc_segment = 0.0 # Fixed length for line segments that divide arcs, 0 to disable
mm_max_arc_error = 0.01 # The maximum error for line segments that divide arcs 0 to disable
arc_correction = 5
default_acceleration = 1000.0 # default acceleration in mm/sec²
arm_solution = cartesian
x_axis_max_speed = 30000 # Maximum speed in mm/min
y_axis_max_speed = 30000 # Maximum speed in mm/min
z_axis_max_speed = 1800 # Maximum speed in mm/min

[planner]
junction_deviation = 0.05
#z_junction_deviation = 0.0
minimum_planner_speed = 0
planner_queue_size = 32

[actuator]
common.motor_reset_pin = GPIO3_5 # reset pin for all drivers

alpha.steps_per_mm = 400 # Steps per mm for alpha ( X ) stepper
alpha.step_pin = pe.14 # Pin for alpha stepper step signal
alpha.dir_pin = pb.0 # Pin for alpha stepper direction, add '!' to reverse direction
alpha.max_rate = 1800.0 # Maximum rate in mm/min

beta.steps_per_mm = 400 # Steps per mm for beta ( Y ) stepper
beta.step_pin = pe.9 # Pin for beta stepper step signal
beta.dir_pin = pe.11 # Pin for beta stepper direction, add '!' to reverse direction
beta.max_rate = 1800.0 # Maxmimum rate in mm/min

gamma.steps_per_mm = 400 # Steps per mm for gamma ( Z ) stepper
gamma.step_pin = pe.8 # Pin for gamma stepper step signal
gamma.dir_pin = p7.1 # Pin for gamma stepper direction, add '!' to reverse direction
gamma.max_rate = 1800 # Maximum rate in mm/min
gamma.acceleration = 500  # overrides the default acceleration for this axis

# Delta is first extruder, we set common stuff here instead of in extruder section
delta.steps_per_mm = 140        # Steps per mm for extruder stepper
delta.step_pin = p6.11        # Pin for extruder step signal
delta.dir_pin = p6.10         # Pin for extruder dir signal ( add '!' to reverse direction )
delta.acceleration = 500        # Acceleration for the stepper motor mm/sec²
delta.max_rate = 3000.0           # Maximum rate in mm/min

[current control]
current.control = spi    # type of control (spi is used for prime alpha)
alpha.current  = 0.7    # X stepper motor curr
beta.current   = 0.7    # Y stepper motor current
gamma.current  = 0.7    # Z stepper motor current
delta.current  = 1.5    # First extruder stepper motor current

[switch]
fan.enable = true # Enable this module
fan.input_on_command = M106 # Command that will turn this switch on
fan.input_off_command = M107 # Command that will turn this switch off
fan.output_pin = pe.6 # Pin this module controls
fan.output_type = sigmadeltapwm # PWM output settable with S parameter in the input_on_comand

#misc.enable = false             # Enable this module
#misc.input_on_command = M42              # Command that will turn this switch on
#misc.input_off_command = M43              # Command that will turn this switch off
#misc.output_pin = p6.1              # Pin this module controls
#misc.output_type = digital          # Digital means this is just an on or off pin

led1.enable            = true
led1.input_on_command  = M1
led1.input_off_command = M2
led1.output_pin        = pb.6
led1.output_type       = digital

#led2.enable            = true
#led2.input_on_command  = M3
#led2.input_off_command = M4
#led2.output_pin        = gpio2_7
#led2.output_type       = sigmadeltapwm

#but1.enable             = true                     # Enable this module
#but1.input_pin          = gpio0_7!                 # button
#but1.output_on_command  = M1                       # command to send
#but1.output_off_command = M2                       # command to send
#but1.input_pin_behavior = toggle

[temperature switch]
hotend.enable = true            #
hotend.designator = T               # first character of the temperature control designator to use as the temperature sensor to monitor
hotend.switch = fan            # select which switch to use, matches the name of the defined switch
hotend.threshold_temp = 60.0            # temperature to turn on (if rising) or off the switch
hotend.heatup_poll = 15              # poll heatup at 15 sec intervals
hotend.cooldown_poll = 60              # poll cooldown at 60 sec intervals

[extruder]
hotend.enable = true             # Whether to activate the extruder module at all. All configuration is ignored if false
hotend.tool_id = 0               # T0 will select

# Second extruder module configuration
hotend2.enable = false            # Whether to activate the extruder module at all. All configuration is ignored if false
hotend2.tool_id = 1               # T1 will select

hotend2.x_offset = 0             # x offset from origin in mm
hotend2.y_offset = 25.0          # y offset from origin in mm
hotend2.z_offset = 0             # z offset from origin in mm

[temperature control]
hotend.enable = true             # Whether to activate this ( 'hotend' ) module at all.
hotend.tool_id = 0               # T0 will select
hotend.thermistor_pin = ADC0_1     # Pin for the thermistor to read
hotend.heater_pin = P6.2         # Pin that controls the heater, set to nc if a readonly thermistor is being defined
hotend.thermistor = EPCOS100K    # See http://smoothieware.org/temperaturecontrol#toc5
hotend.set_m_code = 104          # M-code to set the temperature for this module
hotend.set_and_wait_m_code = 109 # M-code to set-and-wait for this module
hotend.designator = T            # Designator letter for this module
hotend.pwm_frequency = 100       # FIXME slow for now when is SPIFI

hotend2.enable = false            # Whether to activate this ( 'hotend' ) module at all.
hotend2.tool_id = 1               # T1 will select
hotend2.thermistor_pin = ADC0_3   # Pin for the thermistor to read
hotend2.heater_pin = p2.5         # Pin that controls the heater, set to nc if a readonly thermistor is being defined
hotend2.thermistor = EPCOS100K    # See http://smoothieware.org/temperaturecontrol#toc5
hotend2.set_m_code = 104          # M-code to set the temperature for this module
hotend2.set_and_wait_m_code = 109 # M-code to set-and-wait for this module
hotend2.designator = T            # Designator letter for this module

bed.enable = true                 # Whether to activate this module at all.
bed.thermistor_pin = ADC0_2       # Pin for the thermistor to read
bed.heater_pin = p6.9             # Pin that controls the heater
bed.thermistor = Honeywell100K    # See http://smoothieware.org/temperaturecontrol#thermistor
bed.set_m_code = 140              # M-code to set the temperature for this module
bed.set_and_wait_m_code = 190     # M-code to set-and-wait for this module
bed.designator = B                # Designator letter for this module
bed.pwm_frequency = 100           # FIXME slow for now when is SPIFI

[kill button]
enable = false         # Set to true to enable a kill button
pin = p2.7             # Kill button pin.
toggle_enable = false  # set to true to make it a toggle button (like an estop)
unkill_enable = true   # enable kill button hold for 2 seconds does unkill

[system leds]
idle_led = p7.4    # flashes when running but idle - led1
play_led = p7.5    # on when playing, flashes when halted - led2
# led3 p7.6
# led4 pb.6

[pwm]
frequency=10000        # PWM frequency
[laser]
enable = false # Whether to activate the laser module at all
pwm_pin = P1.8 # This pin will be PWMed to control the laser.
#inverted_pwm = false # set to true to invert the pwm
#ttl_pin = P1.30  # This pin turns on when the laser turns on, and off when the laser turns off.
#maximum_power = 1.0 # This is the maximum duty cycle that will be applied to the laser
#minimum_power = 0.0 # This is a value just below the minimum duty cycle that keeps the laser active without actually burning.
#default_power = 0.8 # This is the default laser power that will be used for cuts if a power has not been specified.  The value is a scale between the maximum and minimum power levels specified above

[endstops]
common.debounce_ms = 0         # debounce time in ms (actually 10ms min)
#common.is_delta = true
#common.homing_order = XYZ     # order in which axis homes (if defined)

minx.enable = true             # enable an endstop
minx.pin = p4.0                # pin
minx.homing_direction = home_to_min      # direction it moves to the endstop
minx.homing_position = 0                # the cartesian coordinate this is set to when it homes
minx.axis = X                # the axis designator
minx.max_travel = 500              # the maximum travel in mm before it times out
minx.fast_rate = 30               # fast homing rate in mm/sec
minx.slow_rate = 5               # slow homing rate in mm/sec
minx.retract = 5                # bounce off endstop in mm
minx.limit_enable = false        # enable hard limit

miny.enable = true                  # enable an endstop
miny.pin = pf.9                     # pin
miny.homing_direction = home_to_min # direction it moves to the endstop
miny.homing_position = 0            # the cartesian coordinate this is set to when it homes
miny.axis = Y                       # the axis designator
miny.max_travel = 500               # the maximum travel in mm before it times out
miny.fast_rate = 30                 # fast homing rate in mm/sec
miny.slow_rate = 5                  # slow homing rate in mm/sec
miny.retract = 5                    # bounce off endstop in mm
miny.limit_enable = false            # enable hard limits

#minz.pin = pf.8
#probe.pin = pb.3

#maxx.pin = pb.4
#maxy.pin = pb.5
#maxz.pin = pb.2

